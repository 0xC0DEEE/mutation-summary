<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>MutationSummary test</title>
<script src="http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js"></script>
<script src="mutation_summary.js"></script>

<script>
goog.require('goog.testing.jsunit');
goog.require('goog.testing.AsyncTestCase');
</script>
</head>
<body>
  <div id="test-div"></div>

<script>

var testCase = goog.testing.AsyncTestCase.createAndInstall(document.title);
testCase.stepTimeout = 5 * 1000;

var continueTesting = testCase.continueTesting.bind(testCase);

var testDiv;
var observer;
var observing;
var changed;

function resetChanged(summary) {
  if (summary) {
    changed = summary;
  } else {
    changed = {
      added: [],
      removed: [],
      reparented: [],
      reordered: [],
      characterData: []
    }
  }
}

function startObserving(options) {
  options = options || {
    childList: true,
    reordered: true
  };

  options.rootNode = testDiv;
  options.callback = resetChanged;

  observer = new MutationSummary(options);
  observing = true;
}

function stopObserving() {
  if (observing)
      observer.disconnect();

  observing = false;
}

function setUp() {
  testDiv = document.getElementById('test-div');
  testDiv.__id__ = 1;
}

function tearDown() {
  stopObserving();
  testDiv.textContent = '';
}

function compareNodeArrayIgnoreOrder(expected, actual) {
  assertEquals(expected.length, actual.length);
  expected.forEach(function(node) {
    assertTrue(actual.indexOf(node) >= 0);
  });
}

function assertSubtreeChanges(expectAdded,
                              expectReparented,
                              expectReordered,
                              expectRemoved) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectAdded, changed.added);
    compareNodeArrayIgnoreOrder(expectRemoved, changed.removed);
    compareNodeArrayIgnoreOrder(expectReparented, changed.reparented);

    assert(typeof expectReordered === typeof changed.reordered);
    if (expectReordered)
      compareNodeArrayIgnoreOrder(expectReordered, changed.reordered);

    promise.continue();
  }, 0);

  return promise;
}

function assertAttributeChanges(expectNodes, expectAttributeData) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectNodes,
      changed.attributes.map(function(change, index) {
        assertObjectEquals(expectAttributeData[index], change.attributes);
        return change.target;
      })
    );

    promise.continue();
  }, 0);

  return promise;
}

function assertCharacterDataChanges(expectNodes,
                                    expectOldValues) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectNodes,
      changed.characterData.map(function(change, index) {
        assertEquals(expectOldValues[index], change.oldValue);
        return change.target;
      })
    );

    promise.continue();
  }, 0);

  return promise;
}

function testOptionsValidation() {
  // Unknown option.
  assertThrows(function() {
    new MutationSummary({
      childList: true,
      schmildList: true,
      callback: function() {}
    });
  });

  // callback is required.
  assertThrows(function() {
    new MutationSummary({
      attributes: true
    });
  });

  // callback must be a function.
  assertThrows(function() {
    new MutationSummary({
      attributes: true,
      callback: 'foo'
    });
  });

  // elementFilter requires childList.
  assertThrows(function() {
    new MutationSummary({
      attributes: true,
      elementFilter: ['div'],
      callback: function() {}
    });
  });

  // attributeFilter requires attributes.
  assertThrows(function() {
    new MutationSummary({
      childList: true,
      attributeFilter: ['foo'],
      callback: function() {}
    });
  });

  // Invalid elementFilter syntanx.
  assertThrows(function() {
    new MutationSummary({
      childList: true,
      elementFilter: ['div[noTrailingBracket'],
      callback: function() {}
    });
  });

  assertThrows(function() {
    new MutationSummary({
      attributes: true,
      attributeFilter: [],
      callback: function() {}
    });
  });

  assertThrows(function() {
    new MutationSummary({
      attributes: true,
      attributeFilter: [' '],
      callback: function() {}
    });
  });

  assertThrows(function() {
    new MutationSummary({
      attributes: true,
      attributeFilter: ['"'],
      callback: function() {}
    });
  });
}

function testAttributesBasic() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag');

  startObserving({
    attributes: true
  });

  div.setAttribute('foo', 'bar2');
  div.setAttribute('baz', 'bat2');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag2');
  div.setAttribute('boo', 'bag3');

  assertAttributeChanges([div],
      [{ 'foo': 'bar', 'boo': 'bag' }]).then(continueTesting);
}

function testAttributesAndElementFilter() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag');

  startObserving({
    childList: true,
    elementFilter: ['div[foo]'],
    attributes: true
  });

  div.setAttribute('foo', 'bar2');
  div.setAttribute('baz', 'bat2');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag2');
  div.setAttribute('boo', 'bag3');

  assertAttributeChanges([div],
      [{ 'foo': 'bar', 'boo': 'bag' }]).then(continueTesting);
}

function testAttributesFilter() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag');

  startObserving({
    attributes: true,
    attributeFilter: ['foo', 'boo']
  });

  div.setAttribute('foo', 'bar2');
  div.setAttribute('baz', 'bat2');
  div.setAttribute('boo', 'bag2');
  div.setAttribute('boo', 'bag');

  assertAttributeChanges([div],
      [{ 'foo': 'bar' }]).then(continueTesting);
}

function testAttributesFilterAndElementFilter() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag');

  startObserving({
    attributes: true,
    childList: true,
    attributeFilter: ['foo', 'boo'],
    elementFilter: ['  div[  baz  ]']
  });

  div.setAttribute('foo', 'bar2');
  div.setAttribute('baz', 'bat2');
  div.setAttribute('boo', 'bag2');
  div.setAttribute('boo', 'bag');

  assertAttributeChanges([div],
      [{ 'foo': 'bar' }]).then(continueTesting);
}

function testCharacterDataBasic() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.innerHTML = 'foo';
  var text = div.firstChild;
  var comment = div.appendChild(document.createComment('123'));

  startObserving({
    characterData: true
  });
  text.textContent = 'bar';
  comment.textContent = '456'
  assertCharacterDataChanges([text, comment], ['foo', '123']).then(function() {
    text.textContent = 'baz';
    text.textContent = 'bat';
    assertCharacterDataChanges([text], ['bar']).then(function() {
      text.textContent = 'bar';
      text.textContent = 'bat'; // Restoring its original value should mean
                                // we won't hear about the change.
      assertCharacterDataChanges([], []).then(continueTesting);
    });
  });
}

function testElementFilterBasic() {
  testCase.waitForAsync();

  startObserving({
    childList: true,
    reordered: true,
    elementFilter: ['div', 'A', 'p']
  });

  var div = testDiv.appendChild(document.createElement('div'));
  var span = div.appendChild(document.createElement('span'));
  var p = testDiv.appendChild(document.createElement('P'));

  assertSubtreeChanges([div, p], [], [], []).then(continueTesting);
}

function testElementFilterAttributeSpecified() {
  testCase.waitForAsync();

  startObserving({
    childList: true,
    reordered: true,
    elementFilter: ['div[foo]', 'A', 'p[bar]', 'div[ baz = "bat" ]']
  });

  var div = testDiv.appendChild(document.createElement('div'));
  div.id = 'div1';
  div.setAttribute('foo', 'foo');
  var div2 = testDiv.appendChild(document.createElement('div'));
  div2.setAttribute('fooz', 'foo');
  var div3 = testDiv.appendChild(document.createElement('div'));
  div3.setAttribute('baz', 'fat');

  var span = div.appendChild(document.createElement('span'));
  var p = testDiv.appendChild(document.createElement('P'));
  p.setAttribute('baz', 'baz');

  assertSubtreeChanges([div], [], [], []).then(function() {
    div.removeAttribute('foo');
    p.removeAttribute('baz');
    p.setAttribute('bar', 'bar');
    div3.setAttribute('baz', 'bat');
    assertSubtreeChanges([p, div3], [], [], [div]).then(continueTesting);
  });
}

function testAddRemoveBasic() {
  testCase.waitForAsync();

  startObserving();

  var div = testDiv.appendChild(document.createElement('div'));
  var span = div.appendChild(document.createElement('span'));
  assertSubtreeChanges([div, span], [], [], []).then(function() {

    div.removeChild(span);
    assertSubtreeChanges([], [], [], [span]).then(continueTesting);
  });
}

function testAddAndRemoveOutsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  startObserving();
  testDiv.removeChild(div1);
  // This add will be ignored since this is a detached subtree.
  div1.appendChild(document.createElement('span'));
  div1.removeChild(div2);
  div2.removeChild(span);
  assertSubtreeChanges([], [], [], [div1, div2, span]).then(function() {

    // This add will be ignored because it happens outside the document tree.
    div1.appendChild(document.createElement('span'));
    assertSubtreeChanges([], [], [], []).then(continueTesting);
  });
}

function testAddOutsideOfTreeAndReinsert() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));

  startObserving();
  testDiv.removeChild(div1);
  // This add is taking place while outside the tree, but should be considered
  // and 'add' because the parent node is later replaced.
  var span = div1.appendChild(document.createElement('span'));
  testDiv.appendChild(div1);
  assertSubtreeChanges([span], [], [], []).then(continueTesting);
}

function testMove() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  testDiv.appendChild(div2);
  testDiv.appendChild(div1);

  assertSubtreeChanges([], [div2], [], []).then(continueTesting);
}

function testAddingToDetachedSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));

  startObserving();
  testDiv.removeChild(div1);
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  assertSubtreeChanges([], [], [], [div1]).then(continueTesting);
}

function testReorderInsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  testDiv.appendChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [div1, div2, div3], [], []).then(continueTesting);
}

function testReorderInsideTreeAndAddMiddle() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  testDiv.appendChild(div3);
  div3.appendChild(div2);
  var div4 = document.createElement('div');
  div2.appendChild(div4);
  div4.appendChild(div1);

  assertSubtreeChanges([div4], [div1, div2, div3], [], []).then(continueTesting);
}

function testReorderOutsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [], [], []).then(continueTesting);
}

function testReorderAndRemoveFromTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [], [], [div1, div2, div3]).then(continueTesting);
}

function testReorderAndRemoveSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  testDiv.appendChild(div2);
  div2.appendChild(div1);
  div2.removeChild(div1);

  assertSubtreeChanges([], [div2], [], [div1]).then(continueTesting);
}

function testReorderOutsideAndAddToTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);
  testDiv.appendChild(div3);

  assertSubtreeChanges([div1, div2, div3], [], [], []).then(continueTesting);
}

function testReorderOutsideAndAddSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.appendChild(div1);
  testDiv.appendChild(div2);

  assertSubtreeChanges([div1, div2], [], [], []).then(continueTesting);
}

function testRemoveSubtreeAndAddToExternal() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = document.createElement('div');

  startObserving();
  testDiv.removeChild(div1);
  div3.appendChild(div1);

  assertSubtreeChanges([], [], [], [div1, div2]).then(continueTesting);
}

function insertAfter(parent, node, refNode) {
  parent.insertBefore(node, refNode ? refNode.nextSibling : parent.firstChild);
}

function testMoveDetectNoop() {
  testCase.waitForAsync();

  // Setup
  var divA = testDiv.appendChild(document.createElement('div'));
  divA.id = 'a';
  var divB = testDiv.appendChild(document.createElement('div'));
  divB.id = 'b';
  var divC = testDiv.appendChild(document.createElement('div'));
  divC.id = 'c';
  var divD = testDiv.appendChild(document.createElement('div'));
  divD.id = 'd';
  var divE = testDiv.appendChild(document.createElement('div'));
  divE.id = 'e';
  var divF = testDiv.appendChild(document.createElement('div'));
  divF.id = 'f';
  var divG = document.createElement('div');
  divG.id = 'g';

  startObserving();                 // A  B  C  D  E  F

  insertAfter(testDiv, divD, divA); // A [D] B  C  E  F
  insertAfter(testDiv, divC, divA); // A [C  D] B  E  F
  insertAfter(testDiv, divB, divC); // A [C  B  D] E  F
  insertAfter(testDiv, divD, divA); // A [D  C  B] E  F
  insertAfter(testDiv, divG, divE); // A [D  C  B] E [G] F
  insertAfter(testDiv, divE, divG); // A [D  C  B  G  E] F

  // Final effect is A [D] C [B G] E F

  assertSubtreeChanges([divG], [], [divD, divB], []).then(continueTesting);
}

function testMoveDetectNoopSimple() {
  testCase.waitForAsync();

  // Setup
  var divA = testDiv.appendChild(document.createElement('div'));
  divA.id = 'a';
  var divB = testDiv.appendChild(document.createElement('div'));
  divB.id = 'b';

  startObserving();                 // A  B

  insertAfter(testDiv, divA, divB); // B [A]
  insertAfter(testDiv, divB, divA); // [A B]
  insertAfter(testDiv, divA, divB); // [B A]

  // Final effect is B A

  assertSubtreeChanges([], [], [divB], []).then(continueTesting);
}

function testReorderedRequiresOption() {
  testCase.waitForAsync();

  // Setup
  var divA = testDiv.appendChild(document.createElement('div'));
  divA.id = 'a';
  var divB = testDiv.appendChild(document.createElement('div'));
  divB.id = 'b';

  startObserving({
    childList: true
  });

  insertAfter(testDiv, divA, divB);

  assertSubtreeChanges([], [], undefined, []).then(continueTesting);
}

function testIgnoreOwnChanges() {
  testCase.waitForAsync();

  var count = 0;

  var summary1 = new MutationSummary({
    childList: true,
    observeOwnChanges: false,
    callback: function(summary) {
      count++;

      if (count == 1) {
        assertEquals(1, summary.added.length)
        div = testDiv.appendChild(document.createElement('div'));
      } else if (count == 2) {
        assertEquals(2, summary.added.length);
        div = testDiv.appendChild(document.createElement('div'));
        summary1.disconnect();
      } else if (count == 3) {
        assertEquals(1, summary.added.length);
        summary1.disconnect();
        continueTesting();
      }
    }
  })

  var summary2 = new MutationSummary({
    childList: true,
    observeOwnChanges: false,
    callback: function(summary) {
      count++;

      if (count == 1) {
         assertEquals(1, summary.added.length)
         div = testDiv.appendChild(document.createElement('div'));
       } else if (count == 2) {
         assertEquals(2, summary.added.length);
         div = testDiv.appendChild(document.createElement('div'));
         summary2.disconnect();
       } else if (count == 3) {
         assertEquals(1, summary.added.length);
         summary2.disconnect();
         continueTesting();
       }
     }
  });

  testDiv.appendChild(document.createElement('div'));
}

</script>
</body>
</html>
