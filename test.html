<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>MutationSummary test</title>
<script src="http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js"></script>
<script src="mutation_summary.js"></script>

<script>
goog.require('goog.testing.jsunit');
goog.require('goog.testing.AsyncTestCase');
</script>
</head>
<body>
  <div id="test-div"></div>

<script>

var testCase = goog.testing.AsyncTestCase.createAndInstall(document.title);
testCase.stepTimeout = 5 * 1000;

var continueTesting = testCase.continueTesting.bind(testCase);

var testDiv;
var observer;
var observing;
var changed;

function resetChanged(summaries) {
  if (summaries) {
    changed = summaries[0];
  } else {
    changed = {
      added: [],
      removed: [],
      reparented: [],
      reordered: [],
      characterData: []
    }
  }
}

function startObserving(query) {
  query = query || { all: true };

  observer = new MutationSummary({
    rootNode: testDiv,
    callback: resetChanged,
    queries: [query]
  });

  observing = true;
}

function stopObserving() {
  if (observing)
      observer.disconnect();

  observing = false;
}

function setUp() {
  testDiv = document.getElementById('test-div');
  testDiv.__id__ = 1;
}

function tearDown() {
  stopObserving();
  testDiv.textContent = '';
}

function compareNodeArrayIgnoreOrder(expected, actual) {
  assertEquals(expected.length, actual.length);

  var map = new MutationSummary.NodeMap;
  expected.forEach(function(node) {
    map.set(node, true);
  });

  actual.forEach(function(node) {
    assertTrue(map.has(node));
  });
}

function assertSubtreeChanges(expectAdded,
                              expectReparented,
                              expectReordered,
                              expectRemoved) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectAdded, changed.added);
    compareNodeArrayIgnoreOrder(expectRemoved, changed.removed);

    assert(typeof expectReparented === typeof changed.reparented);
    if (expectReparented)
      compareNodeArrayIgnoreOrder(expectReparented, changed.reparented);

    assert(typeof expectReordered === typeof changed.reordered);
    if (expectReordered)
      compareNodeArrayIgnoreOrder(expectReordered, changed.reordered);

    promise.continue();
  }, 0);

  return promise;
}

function assertElementChanges(expectAdded,
                              expectReparented,
                              expectChangedNodes,
                              expectOldValues,
                              expectRemoved) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectAdded, changed.added);
    compareNodeArrayIgnoreOrder(expectRemoved, changed.removed);
    compareNodeArrayIgnoreOrder(expectReparented, changed.reparented);

    assert(typeof expectChangedNodes === typeof changed.attributeChanged);
    if (expectChangedNodes) {
      Object.keys(expectChangedNodes).forEach(function(attrName) {
        compareNodeArrayIgnoreOrder(expectChangedNodes[attrName], changed.attributeChanged[attrName]);
        expectOldValues[attrName].forEach(function(attrOldValue, index) {
          assertEquals(expectOldValues[attrName][index], changed.getOldAttribute(expectChangedNodes[attrName][index], attrName));
        });
      });
    }

    promise.continue();
  }, 0);

  return promise;
}

function assertAttributeChanges(expectAddedNodes, expectChangedNodes, expectOldValues, expectRemovedNodes) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectAddedNodes, changed.added);
    compareNodeArrayIgnoreOrder(expectChangedNodes, changed.valueChanged);
    compareNodeArrayIgnoreOrder(expectRemovedNodes, changed.removed);

    expectChangedNodes.forEach(function(node, index) {
      assertEquals(expectOldValues[index], changed.getOldAttribute(node));
    });

    promise.continue();
  }, 0);

  return promise;
}

function assertCharacterDataChanges(expectAddedNodes,
                                    expectChangedNodes,
                                    expectOldValues,
                                    expectRemovedNodes) {
  var promise = {
    then: function(f) {
      this.continue = f;
    }
  };

  resetChanged();

  setTimeout(function() {
    compareNodeArrayIgnoreOrder(expectAddedNodes, changed.added);
    compareNodeArrayIgnoreOrder(expectChangedNodes, changed.valueChanged);
    compareNodeArrayIgnoreOrder(expectRemovedNodes, changed.removed);

    expectChangedNodes.forEach(function(node, index) {
      assertEquals(expectOldValues[index],
                   changed.getOldCharacterData(expectChangedNodes[index]));
    });

    promise.continue();
  }, 0);

  return promise;
}

function testOptionsValidation() {
  // Unknown option.
  assertThrows(function() {
    new MutationSummary({
      blarg: true,
      callback: function() {},
      queries: [{ all: true }]
    });
  });

  // callback is required.
  assertThrows(function() {
    new MutationSummary({
      queries: [{ all: true }]
    });
  });

  // callback must be a function.
  assertThrows(function() {
    new MutationSummary({
      callback: 'foo'
    });
  });

  // queries is required.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
    });
  });

  // queries must contain at least one query request.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: []
    });
  });

  // Valid all request.
  new MutationSummary({
    callback: function() {},
    queries: [{ all: true }]
  });

  // all doesn't allow options.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ all: true, foo: false }]
    });
  });

  // Valid attribute request.
  new MutationSummary({
    callback: function() {},
    queries: [{ attribute: "foo" }]
  });

  // attribute doesn't allow options.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ attribute: "foo", bar: false }]
    });
  });

  // attribute must be a string.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ attribute: 1 }]
    });
  });

  // attribute must be non-zero length.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ attribute: '  ' }]
    });
  });

  // attribute must names must be valid.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ attribute: '1foo' }]
    });
  });

    // attribute must contain only one attribute.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ attribute: 'foo bar' }]
    });
  });

  // Valid element request.
  new MutationSummary({
    callback: function() {},
    queries: [{ element: ['div'] }]
  });

  // Valid element request 2.
  new MutationSummary({
    callback: function() {},
    queries: [{ element: ['div'], elementAttributes: "foo bar" }]
  });

  // elementFilter must contain at least one item
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ element: [] }]
    });
  });

  // Invalid element syntanx.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ element: ['div[noTrailingBracket'], }]
    });
  });

  // Invalid element option
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ element: ['div[foo]'], foo: true }]
    });
  });

  // elememtAttribute must contain valid attribute names
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ element: ['div[foo]'], elementAttributes: 'foo 1bar' }]
    });
  });

  // Invalid element option 2.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ element: ['div[foo]'], elementAttributes: 'foo', foo: true }]
    });
  });

  // Valid characterData request.
  new MutationSummary({
    callback: function() {},
    queries: [{ characterData: true }]
  });

  // Invalid characterData option.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ characterData: true, foo: true }]
    });
  });

  // Invalid query request.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{  }]
    });
  });

  // Invalid query request.
  assertThrows(function() {
    new MutationSummary({
      callback: function() {},
      queries: [{ foo: true  }]
    });
  });
}

function testAttributeBasic() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');

  var div2 = testDiv.appendChild(document.createElement('div'));

  var div3 = document.createElement('div');
  div3.setAttribute('foo', 'bat');

  startObserving({
    attribute: "foo"
  });

  div.setAttribute('foo', 'bar2');
  div2.setAttribute('foo', 'baz');
  testDiv.appendChild(div3);
  div3.setAttribute('foo', 'bat2');

  assertAttributeChanges([div2, div3], [div], ['bar'], []).then(function() {
    div3.setAttribute('foo', 'bat3');
    testDiv.removeChild(div3);
    testDiv.removeChild(div);
    div2.setAttribute('foo', 'baz2');
    assertAttributeChanges([], [div2], ['baz'], [div3, div]).then(continueTesting);
  });
}

// TODO(rafaelw): Add node movement to this.
function testCharacterDataBasic() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.innerHTML = 'foo';
  var text = div.firstChild;
  var comment = div.appendChild(document.createComment('123'));

  startObserving({
    characterData: true
  });
  text.textContent = 'bar';
  comment.textContent = '456'
  var comment2 = div.appendChild(document.createComment('456'));
  comment2.textContent = '789';
  var div2 = testDiv.appendChild(document.createElement('div'));

  assertCharacterDataChanges([comment2], [text, comment], ['foo', '123'], []).then(function() {
    text.textContent = 'baz';
    text.textContent = 'bat';
    div.removeChild(comment2);

    assertCharacterDataChanges([], [text], ['bar'], [comment2]).then(function() {
      text.textContent = 'bar';
      text.textContent = 'bat'; // Restoring its original value should mean
                                // we won't hear about the change.
      assertCharacterDataChanges([], [], [], []).then(continueTesting);
    });
  });
}

function testElementFilterBasic() {
  testCase.waitForAsync();

  startObserving({
    element: ['div', 'A', 'p']
  });

  var div = testDiv.appendChild(document.createElement('div'));
  var span = div.appendChild(document.createElement('span'));
  var p = testDiv.appendChild(document.createElement('P'));

  assertElementChanges([div, p], [], undefined, undefined, []).then(continueTesting);
}

function testElementFilterAttributeSpecified() {
  testCase.waitForAsync();

  startObserving({
    element: ['div[foo]', 'A', '*[bar]', 'div[ baz = "bat" ]']
  });

  var div = testDiv.appendChild(document.createElement('div'));
  div.id = 'div1';
  div.setAttribute('foo', 'foo');
  var div2 = testDiv.appendChild(document.createElement('div'));
  div2.setAttribute('fooz', 'foo');
  var div3 = testDiv.appendChild(document.createElement('div'));
  div3.setAttribute('baz', 'fat');

  var span = div.appendChild(document.createElement('span'));
  var p = testDiv.appendChild(document.createElement('P'));
  p.setAttribute('baz', 'baz');

  assertElementChanges([div], [], undefined, undefined, []).then(function() {
    div.removeAttribute('foo');
    p.removeAttribute('baz');
    p.setAttribute('bar', 'bar');
    div3.setAttribute('baz', 'bat');
    assertElementChanges([p, div3], [], undefined, undefined, [div]).then(continueTesting);
  });
}

function testElementFilterWithElementAttributes() {
  testCase.waitForAsync();

  var div = testDiv.appendChild(document.createElement('div'));
  div.setAttribute('foo', 'bar');
  div.setAttribute('baz', 'bat');
  div.setAttribute('boo', 'bag');

  var div2 = testDiv.appendChild(document.createElement('div'));


  startObserving({
    element: ['  div[  baz  ]'],
    elementAttributes: 'foo boo',
  });

  div.setAttribute('foo', 'bar2');
  div.setAttribute('baz', 'bat2');
  div.setAttribute('boo', 'bag2');
  div.setAttribute('boo', 'bag');

  div2.setAttribute('baz', 'blarg');

  var div3 = testDiv.appendChild(document.createElement('div'));
  div3.setAttribute('baz', 'bar');
  div2.appendChild(div);

  assertElementChanges([div2, div3], [div], { 'foo': [div] }, { 'foo': ['bar'] }, []).then(function() {
    testDiv.appendChild(div);
    div3.removeAttribute('baz');
    testDiv.removeChild(div2);

    assertElementChanges([], [div], {}, {}, [div2, div3]).then(continueTesting);
  });
}

function testAddRemoveBasic() {
  testCase.waitForAsync();

  startObserving();

  var div = testDiv.appendChild(document.createElement('div'));
  var span = div.appendChild(document.createElement('span'));
  assertSubtreeChanges([div, span], [], [], []).then(function() {

    div.removeChild(span);
    assertSubtreeChanges([], [], [], [span]).then(continueTesting);
  });
}

function testAddAndRemoveOutsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  startObserving();
  testDiv.removeChild(div1);
  // This add will be ignored since this is a detached subtree.
  div1.appendChild(document.createElement('span'));
  div1.removeChild(div2);
  div2.removeChild(span);
  assertSubtreeChanges([], [], [], [div1, div2, span]).then(function() {

    // This add will be ignored because it happens outside the document tree.
    div1.appendChild(document.createElement('span'));
    assertSubtreeChanges([], [], [], []).then(continueTesting);
  });
}

function testAddOutsideOfTreeAndReinsert() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));

  startObserving();
  testDiv.removeChild(div1);
  // This add is taking place while outside the tree, but should be considered
  // and 'add' because the parent node is later replaced.
  var span = div1.appendChild(document.createElement('span'));
  testDiv.appendChild(div1);
  assertSubtreeChanges([span], [], [], []).then(continueTesting);
}

function testMove() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  testDiv.appendChild(div2);
  testDiv.appendChild(div1);

  assertSubtreeChanges([], [div2], [], []).then(continueTesting);
}

function testAddingToDetachedSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));

  startObserving();
  testDiv.removeChild(div1);
  var div2 = div1.appendChild(document.createElement('div'));
  var span = div2.appendChild(document.createElement('span'));

  assertSubtreeChanges([], [], [], [div1]).then(continueTesting);
}

function testReorderInsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  testDiv.appendChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [div1, div2, div3], [], []).then(continueTesting);
}

function testReorderInsideTreeAndAddMiddle() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  testDiv.appendChild(div3);
  div3.appendChild(div2);
  var div4 = document.createElement('div');
  div2.appendChild(div4);
  div4.appendChild(div1);

  assertSubtreeChanges([div4], [div1, div2, div3], [], []).then(continueTesting);
}

function testReorderOutsideTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [], [], []).then(continueTesting);
}

function testReorderAndRemoveFromTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  testDiv.removeChild(div1);
  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);

  assertSubtreeChanges([], [], [], [div1, div2, div3]).then(continueTesting);
}

function testReorderAndRemoveSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  testDiv.appendChild(div2);
  div2.appendChild(div1);
  div2.removeChild(div1);

  assertSubtreeChanges([], [div2], [], [div1]).then(continueTesting);
}

function testReorderOutsideAndAddToTree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = div2.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.removeChild(div3);
  div3.appendChild(div2);
  div2.appendChild(div1);
  testDiv.appendChild(div3);

  assertSubtreeChanges([div1, div2, div3], [], [], []).then(continueTesting);
}

function testReorderOutsideAndAddSubtree() {
  testCase.waitForAsync();

  // Setup
  var div1 = document.createElement('div');
  var div2 = div1.appendChild(document.createElement('div'));

  startObserving();

  div1.removeChild(div2);
  div2.appendChild(div1);
  testDiv.appendChild(div2);

  assertSubtreeChanges([div1, div2], [], [], []).then(continueTesting);
}

function testRemoveSubtreeAndAddToExternal() {
  testCase.waitForAsync();

  // Setup
  var div1 = testDiv.appendChild(document.createElement('div'));
  var div2 = div1.appendChild(document.createElement('div'));
  var div3 = document.createElement('div');

  startObserving();
  testDiv.removeChild(div1);
  div3.appendChild(div1);

  assertSubtreeChanges([], [], [], [div1, div2]).then(continueTesting);
}

function insertAfter(parent, node, refNode) {
  parent.insertBefore(node, refNode ? refNode.nextSibling : parent.firstChild);
}

function testMoveDetectNoop() {
  testCase.waitForAsync();

  // Setup
  var divA = testDiv.appendChild(document.createElement('div'));
  divA.id = 'a';
  var divB = testDiv.appendChild(document.createElement('div'));
  divB.id = 'b';
  var divC = testDiv.appendChild(document.createElement('div'));
  divC.id = 'c';
  var divD = testDiv.appendChild(document.createElement('div'));
  divD.id = 'd';
  var divE = testDiv.appendChild(document.createElement('div'));
  divE.id = 'e';
  var divF = testDiv.appendChild(document.createElement('div'));
  divF.id = 'f';
  var divG = document.createElement('div');
  divG.id = 'g';

  startObserving();                 // A  B  C  D  E  F

  insertAfter(testDiv, divD, divA); // A [D] B  C  E  F
  insertAfter(testDiv, divC, divA); // A [C  D] B  E  F
  insertAfter(testDiv, divB, divC); // A [C  B  D] E  F
  insertAfter(testDiv, divD, divA); // A [D  C  B] E  F
  insertAfter(testDiv, divG, divE); // A [D  C  B] E [G] F
  insertAfter(testDiv, divE, divG); // A [D  C  B  G  E] F

  // Final effect is A [D] C [B G] E F

  assertSubtreeChanges([divG], [], [divD, divB], []).then(continueTesting);
}

function testMoveDetectNoopSimple() {
  testCase.waitForAsync();

  // Setup
  var divA = testDiv.appendChild(document.createElement('div'));
  divA.id = 'a';
  var divB = testDiv.appendChild(document.createElement('div'));
  divB.id = 'b';

  startObserving();                 // A  B

  insertAfter(testDiv, divA, divB); // B [A]
  insertAfter(testDiv, divB, divA); // [A B]
  insertAfter(testDiv, divA, divB); // [B A]

  // Final effect is B A

  assertSubtreeChanges([], [], [divB], []).then(continueTesting);
}

function testIgnoreOwnChanges() {
  testCase.waitForAsync();

  var count = 0;

  var summary1 = new MutationSummary({
    observeOwnChanges: false,
    queries: [{ all: true}],
    callback: function(summaries) {
      var summary = summaries[0];
      count++;

      if (count == 1) {
        assertEquals(1, summary.added.length)
        div = testDiv.appendChild(document.createElement('div'));
      } else if (count == 2) {
        assertEquals(2, summary.added.length);
        div = testDiv.appendChild(document.createElement('div'));
        summary1.disconnect();
      } else if (count == 3) {
        assertEquals(1, summary.added.length);
        summary1.disconnect();
        continueTesting();
      }
    }
  })

  var summary2 = new MutationSummary({
    observeOwnChanges: false,
    queries: [{ all: true}],
    callback: function(summaries) {
      var summary = summaries[0];
      count++;

      if (count == 1) {
         assertEquals(1, summary.added.length)
         div = testDiv.appendChild(document.createElement('div'));
       } else if (count == 2) {
         assertEquals(2, summary.added.length);
         div = testDiv.appendChild(document.createElement('div'));
         summary2.disconnect();
       } else if (count == 3) {
         assertEquals(1, summary.added.length);
         summary2.disconnect();
         continueTesting();
       }
     }
  });

  testDiv.appendChild(document.createElement('div'));
}

</script>
</body>
</html>
