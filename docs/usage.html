<html>
<head>
<link rel="stylesheet" href="style.css">
</head>
<body>

<h1>Mutation Summary Library: API Usage</h1>

<h2>Overview</h2>

<p>The MutationSummary library exports a single JavaScript class of the same name: <code>MutationSummary(...)</code>. When created, it takes care of the details of observing the DOM for changes, computing the "net-effect" of what's changed and then delivers these changes to the provided callback.</p>

<h3>Requirements</h3>

<p><code>MutationSummary</code> depends on the presence of DOM <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#mutation-observers">Mutation Observers</a> to do its work. At this time, Mutation Observers are implemented in <a href="http://www.webkit.org/">WebKit</a> and available for use in the <a href="http://dev.chromium.org/getting-involved/dev-channel">Chrome Dev Channel</a>.

<h3>Synopsis</h3>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  queries: [{ element: 'div' }]
});

// handleChanges is invoked after changes have occurred.
function handleChanges(summaries) {
  var elementSummary = summaries[0];
  // ... handle here ...
}

// ... discontinues delivery of changes
observer.disconnect();
</pre></code>

<p>The <code>MutationSummary</code> object is constructed with a single object argument which contains its configuration options. The most important configuration is the <code>queries</code> property which is an array that must contain at least one "query".</p>

<p>A Query is a "view" of what has changed in the observed subtree. There are four types of queries: <code>attribute</code>, <code>element</code>, <code>characterData</code> and <code>all</code>.</p>

The <code>callback</code> function is invoked with a single argument which is an array of "Summaries", each corresponding to the results of the one of the provided queries. Different queries deliver different bits of information.</p>

<h2>Query Types</h2>

<h3>Observing attributes</h3>

<p>The simplest case to consider is the <code>attribute</code> query.</p> Observation is begun as soon as the <code>MutationSummary</code> object is created.</p>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  queries: [{ attribute: 'myAttribute' }]
});
</pre></code>

<p>This instructs the MutationSummary to watch for changes to the myAttribute attribute throughout the entire document.</p>

<p>You can imagine that at this time, it collects the set of elements in the document which have the myAttribute attribute, i.e. <code>document.querySelector('*[myAttribute]')</code>, and stores the result in an internal list. It doesn't actually do this, because it would be far too slow, but it's helpful to think about it this way.</p>

<p>When changes have occurred that this attribute query cares about, the provided <code>handleChanges</code> callback is invoked. The corresponding summary which is delivered looks like this:</p>

<code><pre>
{
  added: [array of nodes],
  removed: [array of nodes],
  valueChanged: [array of nodes],
  getOldAttribute: function(node) { ... }
}
</pre></code>

<p>Let's imagine that immediately before invoking <code>handleChanges</code>, the MutationSummary performed the same <code>querySelector()</code> operation to determine what elements have myAttribute now. The <code>added</code> array contains elements which would be present in this set but would have been absent in the earlier one. The <code>removed</code> array contains elements which would have been in the earlier set, but absent in the present one. The <code>valueChanged</code> array contains elements which would have been in both sets (remained in the document), but for whom the <em>value</em> of myAttribute has changed. Passing any of these elements to the provided <code>getOldAttribute</code> function will return the previous value of myAttribute for the given element.</p>

<h3>Observation options</h3>

<p>Before we move on to looking at the other queries, let's stop and look at two important options that apply to all queries. They have sensible default values, but may be useful to override. We could have created our MutationSummary like this:</p>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  rootNode: myDiv,
  observeOwnChanges: true,
  queries: [{ attribute: 'myAttribute' }]
});
</pre></code>

<h4>rootNode</h4>

<p>The <code>rootNode</code> option allows you to create an MutationSummary which is observing a DOM subtree rooted at the provided node (myDiv, in this case). This can be useful if you know you only care about a portion of the document, or if you want to observe a subtree which isn't contained in the current <code>window.document</code>. If left absent, window.document is used as the root of observation and the entire default document is observed for changes.</p>

<h4>observeOwnChanges</h4>

<p><code>observeOwnChanges</code> defaults to <code>false</code> which has the effect that MutationSummary doesn't track changes that are made to the DOM <em>during</em> the course of its callback. This is almost always what you want: it's just not especially useful to be told later about the changes you made. However, if you want to have those changes included, simply set <code>observeOwnChanges</code> to <code>true</code>.</p>

<h3>Observing characterData</h3>

<p>"character data" is an umbrella description for nodes which can live in a DOM subtree as children of element or the document but that only have a textContent. Text nodes are the most common form, there are others (such as Comment nodes). The <code>characterData</code> query looks like this: <code>{ characterData: true }</code> and returns much the same data as the <code>attribute</code> query:</p>

<code><pre>
{
  added: [array of nodes],
  removed: [array of nodes],
  valueChanged: [array of nodes],
  getOldCharacterData: function(node) { ... }
}
</pre></code>

<p>As you might expect, <code>added</code> contains new character data nodes, <code>removed</code> contains characterData nodes which have been removed, and <code>valueChanged</code> contains characterData nodes which have remained but whose textValue has changed. To get the previous textValue of any <code>valueChanged</code> node, pass it to <code>getOldCharacterData</code>.</p>

<h3>Observing elements</h3>

<p>Here's where it gets interesting: observing elements is what most use cases will probably want to do. Because of this, the element query is the most flexible, but let's start with the basic case which should look mostly familiar by now:</p>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  queries: [{ element: 'a' }]
});
</pre></code>

<p>This requests the MutationSummary to track all anchor ('a') elements in the document. It delivers the following:</p>

<code><pre>
{
  added: [array of nodes],
  removed: [array of nodes],
  reparented: [array of nodes],
}
</pre></code>

<p><code>added</code> and <code>removed</code> are what you would expect: added and removed anchor elements. The only thing new here is the <code>reparented</code> array. <code>reparented</code> informs you that the following anchors remained in the document, but were moved to a new hierarchy position in the document, i.e. their current parentNode is different from their previous parentNode. This last bit of information is useful in use cases that depend on an element's parent or ancestry.</p>

<h4>More complex "elements"</h4>

<p>MutationSummary allows for a very lenient notion of what an element is. An element can simply be a tag name, but it can also be something more complex, such as <code>'*[widgetClass=button]'</code> -- which treats any element with a widgetClass attribute set to "button" as the "element" for the purposes of the query. An element query can specify its "element" as:</p>

<ul>
  <li>A tagName, i.e. "div"</li>
  <li>*, which matches any element's tagName</li>
  <li>A className, i.e. ".myClass"</li>
  <li>A tagName with a className, i.e. "div.myClass"</li>
  <li>A tagName (or *) with a single attribute name, i.e. "div[foo]" or "*[bar]"</li>
  <li>A tagName (or *) with a single attribute name and value, i.e. "div[foo=val1]" or "*[bar='my quoted string value']"</li>
</ul>

<p>Further more, an element can be specified with multiple patterns. For example: "div *[foo]". In this case, any DOM element is considered to be a query "element" if <em>any</em> of the provided patterns match.</p>

<h4>Observing attribute changes to matched "elements"</h4>

<p>The element query optionally allows for observing changes to specific attribute values of the observed "element":</p>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  queries: [{ element: 'div *[bar]', elementAttributes: 'foo bar' }]
});
</pre></code>

<p>If <code>elementAttributes</code> is requested with the element query, then any matching elements which have stayed in the document and have had any of the specified attributes change value are reported with the summary, in a property called <code>attributeChanged</code> which will be an object of key-value pairs where the key is a requested attribute name and the value is an array of elements which had that attribute change value. In this case, </p>

<code><pre>
{
  added: [array of nodes],
  removed: [array of nodes],
  reparented: [array of nodes],
  attributeChanged: {
    'foo': [array of nodes],
    'bar': [array of nodes]
  },
  getOldAttribute(node, attrName) { ... }
}
</pre></code>

<h3>Observing all changes</h3>

<p>If you want to know about all changes, you can use the <code>all</code> query:</p>

<code><pre>
var observer = new MutationSummary({
  callback: handleChanges,
  queries: [{ all: true }]
});
</pre></code>

<p>The <code>all</code> is useful for many things, including mirroring the entire contents of a document. The data it reports is the union of the data reported by other queries, plus one more useful bit:</p>

<code><pre>
{
  added: [array of nodes],
  removed: [array of nodes],
  reparented: [array of nodes],
  reordered: [array of nodes], // only available for all: true
  characterDataChanged: [array of nodes],
  attributeChanged: {
    'foo': [array of nodes],
    'bar': [array of nodes]
  },
  getOldAttribute(node, attrName) { ... },
  getOldCharacterData(node) { ... }
}
</pre></code>

<p><code>added</code>, <code>removed</code>, and <code>reparented</code> are as before except they may contain any element and any type of character data node. The new member is <code>reordered</code> which contains the set of nodes which remained in the document, and remained children of the same parent, but moved to a new <em>location</em> within their parent's childNodes list. This is useful for correctly mirroring a document, or if the exact location of a node is significant.</p>

<h2>Delivery, interpretation and handling of results</h2>

<p>The MutationSummary callback is invoked after changes occur which its queries care about. Because MutationSummary uses Mutation Observers, the callback is invoked asynchronously, sometime after the underlying changes actually occurred. Describing the exact semantics is outside the scope of this usage guide, but the easiest way to think about it is that callback will be invoked after the event or callback which caused the mutations has exited -- but (nearly always) before the browser repaints.</p>

<p>The results provided to each callback is <em>always true for that observer, from its point of view at the time the callback is invoked</em>.</p>

<p>When a callback is invoked, the callback is guarenteed that it is in the only script currently running and that it is not at risk for causing other observers to interrupt its work if it wishes to further modify the DOM.</p>
</body>
</html>

