<html>
<head>
<link rel="stylesheet" href="style.css">
</head>
<body>

<h1>Mutation Summary Utility Library</h1>

<h2>What is this?</h2>

<p>This library uses the <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#mutation-observers">Mutation Observer DOM API</a> to answer the question:</p>

<pre>  "What happened to this DOM subtree since the last time I saw it?"</pre>

<p>The answer it provides is essentially a "diff" of a DOM subtree from time (n - 1) to time n, but because of the design of Mutation Observers, it is able to provide this information much more efficiently than by performing a brute-force diff computation.
</p>

<h2>What it is useful for?</h2>

<p>Want to find out when the DOM changed in some way? Here's your answer.</p>

<p>Not highfalutin enough for ya? Try this on for size:</p>

<p>Mutation Observation is a powerful mechanism for creating strongly <a href="http://en.wikipedia.org/wiki/Decoupling#Software_Development">decoupled</a> behavior. This allows complex behavior to be built up out of smaller, self-contained components which need to know little to nothing of each other.</p>

<p>In effect, it provides an excellent way for libraries to avoid the need to interact via an explicit imperative API, and instead use the DOM as an implicit API.</p>

<p>Applications include UI widget libraries, templating and databinding mechanisms, accessibility systems, browser extensions and many others.</p>

<h2>How does it help?</h2>

<p>Mutation Observer provides a list of changes which occurred. Making sense of this "log" can be tricky to do correctly. This library provides an implementation which aims to make the "80% use case" easy to implement and highly efficient.</p>

<h4>Because it uses Mutation Observers, this library inherits the properties that:</h4>

<ul>
<li><strong>Observers are kept separate from each other.</strong> This means that for any given observer, when it is notified of changes, it is guarenteed that no other observer is in the middle of mutating the DOM. Conversely, it is guaranteed that it can do its work without being interrupted by another observer. Both of these properties result from Mutation Observer's asynchronous callback semantics.</li>

<li><strong>Generally speaking, observers get to do their work before paint occurs.</strong> Aside from a few instances where DOM APIs can force a synchronous paint (<a href="https://developer.mozilla.org/en/DOM/window.showModalDialog">showModalDialog</a>, for example -- which should be avoided for other reasons), observers can be implemented assuming that they will get to do their work in response to DOM changes <em>before the page repaints</em>, and thus are not at risk for creating visual artifacts like flicker.</li>
</ul>

<h4>Additionally, the design of this library provides that:</h4>

<ul>
<li><strong>The memory and compute expense of delivering results is extremely low.</strong> The algorithmic behavior of this library is such that the complexity is always proportional to the number of underlying mutations which occurred. By comparison, the brute-force diff computation is always proportional to the number of nodes in the observed DOM subtree. As a result, entire classes of applications which were previously impractical are now possible.</li>

<li><strong>By default, observers ignore the effect of their own changes.</strong> Unless otherwise requested, changes made to the DOM during a change notification callback won't be included in the next callback.</li>

<li><strong>Highly complex changes, including changes to DOM structures while they are temporarily outside of the observed subtree are correctly and efficiently handled.</strong> This means that code is safe to remove DOM structures, make changes and then return them to the subtree and observers will be able to make sense of what happened.</li>

<li><strong>Observers are notified of changes if and only if they actually represent a change from that observer's point of view.</strong> For example, if an element is removed and later returned to the same location, nothing has changed from the observer's point of view and nothing will be reported about the change. Similarly if an attribute or text node's value are changed and later returned to the previously value, the observer will be left blissfully ignorant. This is important because (a) observers would prefer to avoid doing unnecessary work and (b) notifications within decoupled systems tend to create cycles of notification and an effective way to prevent this is to guarantee that notifications take place if and only if the underlying value has definitely changed.</li>
</ul>

<h2>In which browsers can I use it?</h2>

<p>This library depends on the presence of the Mutation Observer DOM API, which is very new. At this time, it has been implemented in</p>

<ul>
<li><a href="http://www.webkit.org/">WebKit</a></li>
</ul>

<p>And is available for testing and experimentation in</p>

<ul>
<li><a href="http://tools.google.com/dlpage/chromesxs">Chrome Canary</a> and <a href="http://dev.chromium.org/getting-involved/dev-channel">Dev</a> Channels</li>
</ul>

<h2>What is this not useful for?</h2>

<p>The intent here isn't to be all things to all use-cases. If you want to do any of the following, this library won't do it for you:</p>

<ul>
<li><strong>Use the DOM as some sort of state-transition machine.</strong> This library won't report transient states that the DOM moved through. It will only tell you what the difference is between the previous state and the present one.</li>

<li><strong>Observe complex selectors.</strong> This library offers support for very simple subset of CSS selectors. You can specify a tagName (or "*"), and optionally any one of the following: a single className, a single attribute name, a single attribute value.</li>
</ul>

<p>Note that both of the above use cases are possible given the data that the underlying Mutation Observers API provides -- we simply judged them to be outside the "80% use case".</p>

<h2>How do I use it?</h2>

<p>Check out the <a href="usage.html">API usage</a> document.</p>

<h2>Can I see it in action?</h2>

<p>Sure. Checkout the source and try loading the cool <a href="../examples/pagemirror_extension/">PageMirror</a> extension which demonstrates mirroring the contents of one tab in another.</p>
</body>
</html>